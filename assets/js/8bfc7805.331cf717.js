"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[326],{94551:r=>{r.exports=JSON.parse('{"functions":[{"name":"ErrorBoundary","desc":"This is a React component. Wrap an `ErrorBoundary` around other React components to \\"catch\\" errors\\nand render a fallback UI. The component supports several ways to render a fallback (shown below).\\n\\nFirst, create a fallback component.\\n```lua\\n\\tlocal e = React.createElement\\n\\tlocal Fallback: React.FC<ReactErrorBoundary.FallbackProps> = function(_props)\\n\\t\\treturn e(\\"TextLabel\\", {\\n\\t\\t\\tAnchorPoint = Vector2.new(0.5, 0.5),\\n\\t\\t\\tSize = UDim2.fromScale(0.5, 0.5),\\n\\t\\t\\tPosition = UDim2.fromScale(0.5, 0.5),\\n\\t\\t\\tText = \\"An error was encountered!.\\",\\n\\t\\t})\\n\\tend\\n```\\n\\nNext, in your other components, wrap in an `ErrorBoundary` where needed. When an error is encountered somewhere in your app,\\nthe nearest `ErrorBoundary` will catch and handle it. You don\'t need to wrap every component in an `ErrorBoundary`. Consider\\nthe [granularity of error boundaries](https://aweary.dev/fault-tolerance-react/) and where it makes sense to display an error\\nmessage or revert states.\\n\\n#### Using FallbackComponent prop\\nSee [ErrorIn1SecondFallbackComponent](https://github.com/chriscerie/roact-error-boundary/blob/main/stories/ErrorIn1SecondFallbackComponent.story.lua) for a full example.\\n```lua\\n\\treturn e(ReactErrorBoundary.ErrorBoundary, {\\n\\t\\tFallbackComponent = Fallback,\\n\\t}, {\\n\\t\\tComponentThatErrors = e(ComponentThatErrors),\\n\\t})\\n```\\n\\n#### Using fallbackRender prop\\n[Render prop](https://react.dev/reference/react/Children#calling-a-render-prop-to-customize-rendering) function that returns the fallback UI.\\nThis is helpful if you want to handle errors differently based on the error.\\n\\nSee [ErrorIn1SecondFallbackComponent](https://github.com/chriscerie/roact-error-boundary/blob/main/stories/ErrorIn1SecondFallbackRender.story.lua) for a full example.\\n\\n:::caution\\nRender prop functions are normal functions and are not React components. Attempting to use hooks in them will error!\\n:::\\n\\n```lua\\n\\treturn e(ReactErrorBoundary.ErrorBoundary, {\\n\\t\\tfallbackRender = function(props: ReactErrorBoundary.FallbackProps)\\n\\t\\t\\treturn e(Fallback)\\n\\t\\tend,\\n\\t}, {\\n\\t\\tComponentThatErrors = e(ComponentThatErrors),\\n\\t})\\n```\\n\\n#### Using fallback prop\\nSee [ErrorIn1SecondFallback](https://github.com/chriscerie/roact-error-boundary/blob/main/stories/ErrorIn1SecondFallback.story.lua) for a full example.\\n\\n:::caution\\nThis creates the fallback element even when it\'s not needed.\\n:::\\n\\n```lua\\n\\treturn e(ReactErrorBoundary.ErrorBoundary, {\\n\\t\\tfallback = e(Fallback),\\n\\t}, {\\n\\t\\tComponentThatErrors = e(ComponentThatErrors),\\n\\t})\\n```\\n\\n#### onError\\nWhen passed, `onError` gets called when an error is caught. This is useful for logging errors.\\n\\n```lua\\n\\treturn e(ReactErrorBoundary.ErrorBoundary, {\\n\\t\\tFallbackComponent = Fallback,\\n\\t\\tonError = function(error: LuauPolyfill.Error, info: { componentStack: string })\\n\\t\\t\\twarn(\\"Caught error:\\", error, info)\\n\\t\\tend,\\n\\t}, {\\n\\t\\tComponentThatErrors = e(ComponentThatErrors),\\n\\t})\\n```\\n\\n### onReset\\nWhen passed, `onReset` gets called when the error boundary is reset by a call to `resetErrorBoundary` or when the `resetKeys` change.\\nThis is useful for reverting state.\\n\\nSee [ResetCount](https://github.com/chriscerie/roact-error-boundary/blob/main/stories/ResetCount.story.lua) for a full example.\\n\\n```lua\\n\\treturn e(ReactErrorBoundary.ErrorBoundary, {\\n\\t\\tFallbackComponent = Fallback,\\n\\t\\tonReset = function(\\n\\t\\t\\tdetails: { reason: \\"imperative-api\\",\\n\\t\\t\\targs: { any } } | { reason: \\"keys\\", prev: { any }?, next: { any }? }\\n\\t\\t)\\n\\t\\t\\twarn(\\"Error boundary was reset:\\", details)\\n\\t\\tend,\\n\\t}, {\\n\\t\\tComponentThatErrors = e(ComponentThatErrors),\\n\\t})\\n```","params":[],"returns":[],"function_type":"static","source":{"line":134,"path":"src/ErrorBoundary.lua"}},{"name":"useErrorBoundary","desc":"TODO: Undocumented","params":[],"returns":[],"function_type":"static","source":{"line":22,"path":"src/useErrorBoundary.lua"}},{"name":"withErrorBoundary","desc":"TODO: Undocumented","params":[],"returns":[],"function_type":"static","source":{"line":12,"path":"src/withErrorBoundary.lua"}}],"properties":[],"types":[{"name":"ErrorBoundaryContextType","desc":"","fields":[{"name":"didCatch","lua_type":"boolean","desc":""},{"name":"error","lua_type":"any","desc":""},{"name":"resetErrorBoundary","lua_type":"(...any) -> ()","desc":""}],"source":{"line":11,"path":"src/ErrorBoundaryContext.lua"}},{"name":"FallbackProps","desc":"Props for fallback components. Fallback components should be typed like:\\n```lua\\n\\tlocal Fallback: React.FC<ReactErrorBoundary.FallbackProps> = function(props)\\n\\t\\t-- ...\\n\\tend\\n```","fields":[{"name":"error","lua_type":"Error","desc":""},{"name":"resetErrorBoundary","lua_type":"(...any) -> ()","desc":"Resets the error boundary and calls `onReset` if provided. This is useful for reverting state or retrying the render."}],"source":{"line":32,"path":"src/types.lua"}},{"name":"UseErrorBoundaryApi","desc":"","fields":[{"name":"resetBoundary","lua_type":"() -> ()","desc":""},{"name":"showBoundary","lua_type":"(error: Error) -> ()","desc":""}],"source":{"line":12,"path":"src/useErrorBoundary.lua"}}],"name":"ReactErrorBoundary","desc":"Error boundary for Roact based on react-error-boundary.","source":{"line":17,"path":"src/init.lua"}}')}}]);